Note: c'est une ébauche
... est utilisé pour dénoter les parties manquantes ou à élaborer

Dans le cadre de ce TP, nous allons apprendre à manier le shell Perl 6 pour découvrir
le langage via ses facilités d'introspection. Nous supposons que vous êtes familier
avec le langage Perl 5 car nous soulignerons les similarités et les différences entre
les deux langages.

Nous supposons que vous avez compilé et installé rakudo, ainsi que ack, un utilitaire perl5; 
votre interpréteur perl est 5.x avec x >= 10.
votre répertoire courant est celui des sources rakudo après compilation.

Dans les morceaux de sessions de cet article, le dollar et le caractère
supérieur représent respectivement le prompt du shell unix et celui
de l'interpréteur rakudo. Occasionnellement, nous utiliserons le déboggeur perl5 comme un shell :

  $ perl -dE 0
  DB<1> say 'foo' # soyons fou
  
Note: le  ':5.10' impliqué par -E est perdu.
Utiliser plutôt le Devel::??? de acme qui est plus similaire dans son comportement au shell Perl 6

Une courte session  Perl6

  $ perl6 --version
  This is perl6 version 2012.02-173-gb13c517 built on parrot 4.1.0 revision RELEASE_4_1_0-35-g47bfa1f
  $ perl6
  > say 'a' ~ 'b' # une ligne de code Perl6
  ab
  > exit
  $
  
On voit les numéros de commit abrégés des dépots git et parrot. nqp est curieusement omis.
Notre curiosité insatiable nous amène à chercher quel est le code qui affiche la version de Perl 6.
  
  $ ack --nocolor --nogroup  -i -- 'this is' | grep -w version
  ...
  nqp/src/HLL/Compiler.pm:508:        nqp::say("This is $!language version $version built on parrot $parver revision $parrev");
  ...
  
 En ouvrant ce fichier à la ligne indiqué on trouve : 
 
  method version() {
      my $version := %!config<version>;
      my $parver  := %parrot_config<VERSION>;
      my $parrev  := %parrot_config<git_describe> // '(unknown)';
      nqp::say("This is $!language version $version built on parrot $parver revision $parrev");
      pir::exit__vi(0);
  }
  
C'est du code Perl 6. Il semble à la fois familièr et différent.
Ce code est familier en ce sens que les variables ont des sigils, qu'il y a des espaces de noms, qu'il y a interpolation
de variables dans une chaîne doublement quoté. Nous reviendrons sur cette section de code plus tard.
Ce code est différent. Perl 6, tout au moins dans son mode par défaut, n'est pas une extension de Perl 5.

  
  $ perl6  # on omettra par la suite le lancement d'une session Perl 6
  >  'a' ~ 'b'
  ab
  > 'a'.WHAT
  Str()
  
On voit que pour chaque ligne évaluée, le shell affiche sa valeur. En fait, le shell affiche la valeur de la dernière expression
de la chaîne évaluée. On constate au passage deux nouveautés syntaxiques : la première est la raison de la seconde.
L'opétateur d'appel de méthode n'est plus C<< -> >> mais C<.> (un point) donc le point n'est plus disponible comme
opérateur de concaténation. Le .WHAT est une méthode, qui appliqué à un objet, retourne le type de l'objet.
Notez la convention du pseudo sigil point pour dénoter le nom d'une méthode.

Nous allons beaucoup utiliser les méthodes C<.WHAT>, C<.Str>, C<.perl>, C<.gist> pour savoir à quel type d'objets nous
avons a faire et pour avoir une représentation imprimée :

> 'a'.Str
'a'.Str
a
> 'a'.gist
'a'.gist
a
> 'a'.perl
'a'.perl
"a"
> 

J'ai fait un petit mensonge C<.WHAT> n'est pas vraiment une méthode mais une macro mais la différence nous importe
peu pour le moment. 


Nous avons dis que C<.WHAT> retourne le type d'une objet. Mais quel est le type d'un type?


  > 1.WHAT.WHAT
  1.WHAT.WHAT
  Int()
  > 1.WHAT.WHAT.Str
  1.WHAT.WHAT.Str
  use of uninitialized value of type Int in string context

  > 1.WHAT.WHAT.gist
  1.WHAT.WHAT.gist
  Int()
  > 1.WHAT.WHAT.perl
  1.WHAT.WHAT.perl
  Int
  > say "undefined" unless 1.WHAT.defined
  undefined

...

Ces méthodes existent aussi sous forme de fonctions.

  
...
  


Pour vous mettre en appétit, commençons par un unligne dont le décorticage nous
servira de prétexte à un début d'exploration du langage.

  say "$_: { perl WHAT try  eval $_ }"  for < [] {} () \() :() [] !@@% >
  
Note: BUG perl as a function is missing

Cet uniligne affiche.

[] : Array
{} : Hash
()  : Parcel
\() : Capture
:() : Signature
!@@%: X::Syntax::SigilWithoutName


On voit que le script interprète des chaînes de caractères et affiche le type de la valeur générée
sauf dans le dernier cas où il semble qu'un type d'erreur s'affiche. Notons que C<[]> et C<{}> nous sont
familiers. En Perl 5, c'est la manère de créer respectivement un tableau et un hash.

  $ perl -E 'say ref([]) . " " . ref {}'
  ARRAY HASH

En Perl6, C<[]> et C<{}> sont des composers. C'est du sucre syntaxique pour éviter d'appeler le constructeur
pour un type d'objet donné.	


En voit que beaucoup de choses sont familières au programmeurs Perl5 avec quelque variantes.
Le C<< <I<...>> >> est l'équivalent Perl 6 de C<qw( I<...> )>
  

...

Nous allons découvrir un peu de syntaxe pour exprimer des valeurs natives et des objets.

Perl6 offre des valeurs natives qui peuvent être stockée dans des registres réels ou virtuels (Parrot).
Ces valeurs peuvent être exprimés par des littéraux. Un litéral est une unité atomique syntaxique (ou token)
qui exprime une telle valeur. Beaucoup d'entre elles sont familières à des programmeurs C ou Perl.
1.0, 1, 'toto' expriment respectivement un réel, entier ou chaînes dont les noms de type sont
respectivement C<num>, C<int>, C<str>. La première lettre d'un type natif est minuscule. celle des
autres types est majuscule, pour autant qu'on reste dans l'alphabet latin, ce qui est le cas de ce tutoriel
où nous ne parlerons pas d'Unicode.

On peut utiliser ces valeurs natives comme des objet.

...


Note: Discuter du modèle métaobjet via .HOW
       Couvrir  : Native types, The Mu type, Undefined types, Immutable types, Mutable types, Of types, Container types, 
       Hierarchical types, Polymorphic types, Parameter types, Generic types, The Cool class (and package)
